/*
 * This file was generated by orbit-idl-2 - DO NOT EDIT!
 */

#ifndef SS2012FPGA_H
#define SS2012FPGA_H 1
#define ORBIT_IDL_SERIAL 20
#include <RtORB/corba.h>

#ifdef __cplusplus
#include <RtORB/corba.hh>
extern "C"
{
#endif				/* __cplusplus */

/** typedefs **/
#if !defined(ORBIT_DECL_jp_ac_utsunomiya_is_SS2012FPGA) && !defined(_jp_ac_utsunomiya_is_SS2012FPGA_defined)
#define ORBIT_DECL_jp_ac_utsunomiya_is_SS2012FPGA 1
#define _jp_ac_utsunomiya_is_SS2012FPGA_defined 1
#define jp_ac_utsunomiya_is_SS2012FPGA__freekids CORBA_Object__freekids
   typedef CORBA_Object CORBA_jp_ac_utsunomiya_is_SS2012FPGA;
   typedef CORBA_Object jp_ac_utsunomiya_is_SS2012FPGA;
#ifdef __cplusplus
   namespace jp
   {;
      class SS2012FPGA;
      typedef CORBA_interface::T_Ptr < SS2012FPGA > SS2012FPGA_ptr;
      typedef CORBA_interface::T_Var < SS2012FPGA > SS2012FPGA_var;
      typedef CORBA_interface::T_Helper < SS2012FPGA,
       SS2012FPGA_ptr > SS2012FPGA_helper;
      typedef CORBA_interface::CInArg < SS2012FPGA > SS2012FPGA_CInArg;
      typedef SS2012FPGA_helper SS2012FPGA_COutArg;
      typedef SS2012FPGA_helper SS2012FPGA_CInOutArg;
      typedef SS2012FPGA_helper SS2012FPGA_CppInArg;
      typedef SS2012FPGA_helper SS2012FPGA_CppOutArg;
      typedef SS2012FPGA_helper SS2012FPGA_CppInOutArg;
   }
#endif				// __cplusplus
   extern CORBA_unsigned_long jp_ac_utsunomiya_is_SS2012FPGA__classid
      __attribute__ ((weak));
#if !defined(TC_IMPL_TC_jp_ac_utsunomiya_is_SS2012FPGA_0)
#define TC_IMPL_TC_jp_ac_utsunomiya_is_SS2012FPGA_0 'S'
#define TC_IMPL_TC_jp_ac_utsunomiya_is_SS2012FPGA_1 'S'
#define TC_IMPL_TC_jp_ac_utsunomiya_is_SS2012FPGA_2 '2'
#define TC_IMPL_TC_jp_ac_utsunomiya_is_SS2012FPGA_3 '0'
#define TC_IMPL_TC_jp_ac_utsunomiya_is_SS2012FPGA_4 '1'
#define TC_IMPL_TC_jp_ac_utsunomiya_is_SS2012FPGA_5 '2'
#define TC_IMPL_TC_jp_ac_utsunomiya_is_SS2012FPGA_6 'F'
#define TC_IMPL_TC_jp_ac_utsunomiya_is_SS2012FPGA_7 'P'
#define TC_IMPL_TC_jp_ac_utsunomiya_is_SS2012FPGA_8 'G'
#define TC_IMPL_TC_jp_ac_utsunomiya_is_SS2012FPGA_9 'A'
#ifdef ORBIT_IDL_C_IMODULE_SS2012FPGA
   static
#else
   extern
#endif
   struct CORBA_TypeCode_struct TC_jp_ac_utsunomiya_is_SS2012FPGA_struct;
#define TC_jp_ac_utsunomiya_is_SS2012FPGA ((CORBA_TypeCode)&TC_jp_ac_utsunomiya_is_SS2012FPGA_struct)
#endif
#endif

/** POA structures **/
#ifndef _defined_POA_jp_ac_utsunomiya_is_SS2012FPGA
#define _defined_POA_jp_ac_utsunomiya_is_SS2012FPGA 1
   typedef struct
   {
      void *_private;
      void (*setMotorTorque) (PortableServer_Servant _servant,
			      CORBA_long motorID, CORBA_long maxTorque,
			      CORBA_long torque, CORBA_Environment * ev);
      void (*playAlarmSound) (PortableServer_Servant _servant,
			      CORBA_Environment * ev);
       CORBA_long(*getAlarmSwitchState) (PortableServer_Servant _servant,
					 CORBA_Environment * ev);
      void (*sendIrDAdata) (PortableServer_Servant _servant, CORBA_long data,
			    CORBA_Environment * ev);
   } POA_jp_ac_utsunomiya_is_SS2012FPGA__epv;
   typedef struct
   {
      PortableServer_ServantBase__epv *_base_epv;
      POA_jp_ac_utsunomiya_is_SS2012FPGA__epv
	 *jp_ac_utsunomiya_is_SS2012FPGA_epv;
   } POA_jp_ac_utsunomiya_is_SS2012FPGA__vepv;
   typedef struct
   {
      void *_private;
      POA_jp_ac_utsunomiya_is_SS2012FPGA__vepv *vepv;
   } POA_jp_ac_utsunomiya_is_SS2012FPGA;
   extern CORBA_jp_ac_utsunomiya_is_SS2012FPGA
      impl_jp_ac_utsunomiya_is_SS2012FPGA__create(PortableServer_POA servant,
						  CORBA_Environment * ev);
   extern impl_POA_ServantBase
      *impl_jp_ac_utsunomiya_is_SS2012FPGA__create_servant(PortableServer_POA
							   servant,
							   CORBA_Environment *
							   ev);
   extern void POA_jp_ac_utsunomiya_is_SS2012FPGA__init(PortableServer_Servant
							servant,
							CORBA_Environment *
							ev)
      __attribute__ ((weak));
   extern void POA_jp_ac_utsunomiya_is_SS2012FPGA__fini(PortableServer_Servant
							servant,
							CORBA_Environment *
							ev)
      __attribute__ ((weak));
#endif				/* _defined_POA_jp_ac_utsunomiya_is_SS2012FPGA */

/** skel prototypes **/
   void
      _RtORB_impl_jp_ac_utsunomiya_is_SS2012FPGA_setMotorTorque
      (CORBA_jp_ac_utsunomiya_is_SS2012FPGA _obj, void **result,
       CORBA_Class_Method * _m, void **argv, CORBA_Environment * ev,
       void (*_impl_setMotorTorque) (PortableServer_Servant _servant,
				     CORBA_long motorID, CORBA_long maxTorque,
				     CORBA_long torque,
				     CORBA_Environment * ev))
      __attribute__ ((weak));
   void
      _RtORB_impl_jp_ac_utsunomiya_is_SS2012FPGA_playAlarmSound
      (CORBA_jp_ac_utsunomiya_is_SS2012FPGA _obj, void **result,
       CORBA_Class_Method * _m, void **argv, CORBA_Environment * ev,
       void (*_impl_playAlarmSound) (PortableServer_Servant _servant,
				     CORBA_Environment * ev))
      __attribute__ ((weak));
   void
      _RtORB_impl_jp_ac_utsunomiya_is_SS2012FPGA_getAlarmSwitchState
      (CORBA_jp_ac_utsunomiya_is_SS2012FPGA _obj, void **result,
       CORBA_Class_Method * _m, void **argv, CORBA_Environment * ev,
       CORBA_long(*_impl_getAlarmSwitchState) (PortableServer_Servant
					       _servant,
					       CORBA_Environment * ev))
      __attribute__ ((weak));
   void
      _RtORB_impl_jp_ac_utsunomiya_is_SS2012FPGA_sendIrDAdata
      (CORBA_jp_ac_utsunomiya_is_SS2012FPGA _obj, void **result,
       CORBA_Class_Method * _m, void **argv, CORBA_Environment * ev,
       void (*_impl_sendIrDAdata) (PortableServer_Servant _servant,
				   CORBA_long data, CORBA_Environment * ev))
      __attribute__ ((weak));

/** stub prototypes **/
   void
      jp_ac_utsunomiya_is_SS2012FPGA_setMotorTorque
      (CORBA_jp_ac_utsunomiya_is_SS2012FPGA _obj, CORBA_long motorID,
       CORBA_long maxTorque, CORBA_long torque, CORBA_Environment * ev)
      __attribute__ ((weak));
   void
      jp_ac_utsunomiya_is_SS2012FPGA_playAlarmSound
      (CORBA_jp_ac_utsunomiya_is_SS2012FPGA _obj, CORBA_Environment * ev)
      __attribute__ ((weak));
   CORBA_long
      jp_ac_utsunomiya_is_SS2012FPGA_getAlarmSwitchState
      (CORBA_jp_ac_utsunomiya_is_SS2012FPGA _obj, CORBA_Environment * ev)
      __attribute__ ((weak));
   void
      jp_ac_utsunomiya_is_SS2012FPGA_sendIrDAdata
      (CORBA_jp_ac_utsunomiya_is_SS2012FPGA _obj, CORBA_long data,
       CORBA_Environment * ev) __attribute__ ((weak));
#ifdef ORBIT_IDL_C_IMODULE_SS2012FPGA
   static
#else
   extern
#endif
   CORBA_Class_Impl jp_ac_utsunomiya_is_SS2012FPGA__imp;
#define jp_ac_utsunomiya_is_SS2012FPGA_IMETHODS_LEN 4
#ifdef ORBIT_IDL_C_IMODULE_SS2012FPGA
   static
#else
   extern
#endif
   CORBA_Class_Method
      jp_ac_utsunomiya_is_SS2012FPGA__methods
      [jp_ac_utsunomiya_is_SS2012FPGA_IMETHODS_LEN];

 /** for C++ **/
#ifdef __cplusplus
}

/** C++ class definition(skels)  **/
namespace jp
{
   namespace jp::ac
   {
      namespace jp::ac::utsunomiya
      {
	 namespace jp::ac::utsunomiya::is
	 {
/* orbit-idl-cpp-headers.c(69) */
#ifndef jp_ac_utsunomiya_is_SS2012FPGA_impl_cpp_type_defined
#define jp_ac_utsunomiya_is_SS2012FPGA_impl_cpp_type_defined

	    class SS2012FPGA;
	    class SS2012FPGA__impl:public virtual CORBA::Object
	    {
	     public:
	       SS2012FPGA__impl()
	       {
	       }
	       virtual void setMotorTorque(CORBA::Long motorID,
					   CORBA::Long maxTorque,
					   CORBA::Long torque) = 0;
	       virtual void playAlarmSound() = 0;
	       virtual CORBA::Long getAlarmSwitchState() = 0;
	       virtual void sendIrDAdata(CORBA::Long data) = 0;
	    };

#endif				/* jp_ac_utsunomiya_is_SS2012FPGA_impl_cpp_type_defined */

	 };
      };
   };
};

/** C++ class definition(stubs)  **/
namespace jp
{
   namespace ac
   {
      namespace utsunomiya
      {
	 namespace is
	 {
#ifndef jp_SS2012FPGA_def
#define jp_SS2012FPGA_def

	    class SS2012FPGA:public virtual CORBA::Object
	    {
	     private:
	     public:
	       typedef jp_ac_utsunomiya_is_SS2012FPGA _c_type;
	       typedef SS2012FPGA_ptr _ptr_type;
	       typedef SS2012FPGA_var _var_type;

	       typedef SS2012FPGA_helper _helper_type;

	     public:
	       typedef CORBA::Object _super_type;
	     protected:
	        SS2012FPGA():_super_type()
	       {
	       }

	     public:
	        SS2012FPGA(CORBA_Object impl):CORBA::Object(impl)
	       {
	       }

	       SS2012FPGA *operator->()
	       {
		  return this;
	       };
	        SS2012FPGA & operator=(CORBA_Object);
	       static SS2012FPGA_ptr _narrow(CORBA::Object_ptr ptr);
	       static SS2012FPGA_ptr _duplicate(SS2012FPGA_ptr ptr)
	       {
		  return CORBA_interface::Utils <
		     SS2012FPGA >::duplicate(ptr);
	       }
	       void setMotorTorque(CORBA::Long motorID, CORBA::Long maxTorque,
				   CORBA::Long torque) __attribute__ ((weak));
	       void playAlarmSound() __attribute__ ((weak));
	        CORBA::Long getAlarmSwitchState() __attribute__ ((weak));
	       void sendIrDAdata(CORBA::Long data) __attribute__ ((weak));
	    };

#ifndef jp_ac_utsunomiya_is_SS2012FPGA_operators_defined
#define jp_ac_utsunomiya_is_SS2012FPGA_operators_defined

	    inline void operator<<=(CORBA_any & any, SS2012FPGA_ptr from_)
	    {
	       CORBA_TypeCode tc = TC_CORBA_Object;

	       CORBA_Object val = from_.impl();

	       CORBA::AnyObjectStream::from(any, tc, val);
	    }

#endif /* jp_ac_utsunomiya_is_SS2012FPGA_operators_defined */

#endif /* jp_SS2012FPGA_def */

	 };			/// end namespace
      };			/// end namespace
   };				/// end namespace
};				/// end namespace

/** C++ class definition(POA)  **/
namespace POA_jp
{
   namespace POA_jp_ac
   {
      namespace POA_jp_ac_utsunomiya
      {
	 namespace POA_jp_ac_utsunomiya_is
	 {
#ifndef _defined_POA_CPP_jp_ac_utsunomiya_is_SS2012FPGA
#define _defined_POA_CPP_jp_ac_utsunomiya_is_SS2012FPGA

	    class SS2012FPGA:public virtual jp_ac_utsunomiya_is::
	       SS2012FPGA__impl,
	     public virtual PortableServer::ServantBase
	    {
	       typedef::jp::ac::utsunomiya::is::SS2012FPGA T;

	     public:
	       ::jp::ac::utsunomiya::is::SS2012FPGA_ptr _this()
	       {
		  if (_t == NULL) {
		     CORBA_Object impl = __this(&ev);
		     if (impl != NULL)
		     {
			_t = new T(impl);
		     }
		  }
		  return _t;
	       }

	       SS2012FPGA():_t(NULL)
	       {
		  PortableServer::POA_var poa =
		     PortableServer::ServantBase::_root_POA();
		  poa_servant =
		     impl_jp_ac_utsunomiya_is_SS2012FPGA__create_servant(poa->
									 _impl,
									 &ev);
		  register_PortableServer_Servant(poa->_impl, poa_servant,
						  &ev);
		  _impl =
		     PortableServer_POA_servant_to_reference(poa->_impl,
							     poa_servant,
							     &ev);
		  _impl->impl_obj = static_cast < CORBA::Object * >(this);
	       }

	       ~SS2012FPGA()
	       {
		  delete _t;
		   _t = NULL;
	       }

	     private:
	        T * _t;
	    };

#endif /* _defined_POA_CPP_jp_ac_utsunomiya_is_SS2012FPGA */

	 }

      }

   }

}

/** C++ class definition(global fumctions)  **/
#endif /* __cplusplus */

#endif
#undef ORBIT_IDL_SERIAL
